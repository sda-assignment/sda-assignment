title Admin List Transactions
actor admin
boundary Spring Dispatcher Serverlet
control AdminTransactionController
entity TransactionModel

admin ->Spring Dispatcher Serverlet : Get /admin/transactions
Spring Dispatcher Serverlet ->AdminTransactionController : listTransactions()
AdminTransactionController ->TransactionModel : select(t -> true)
TransactionModel -->AdminTransactionController : ArrayList<Transaction>
AdminTransactionController -->Spring Dispatcher Serverlet : ArrayList<Transaction>


title SignUp

actor user
boundary Spring Dispatcher Serverlet
control AuthController
boundary UserModel

user ->Spring Dispatcher Serverlet : POST /signup
Spring Dispatcher Serverlet ->AuthController : signUp( SignUpBody body)
AuthController -> UserModel : recordExists(userEmail)
alt returns true
UserModel -->AuthController : True
AuthController -->Spring Dispatcher Serverlet : throw new ResponseStatusException()
else returns false
UserModel -->AuthController : False
AuthController ->UserModel : insert(new User(user information))
UserModel -->AuthController :
AuthController -->Spring Dispatcher Serverlet :
end

title Refund Request

actor user
boundary Spring Dispatcher Serverlet
control TransactionController
boundary RefundRequestModel
boundary UserModel
user ->Spring Dispatcher Serverlet : POST /transactions/{id}/refund
Spring Dispatcher Serverlet ->TransactionController : requestRefund(Context ctx, int id)
TransactionController ->RefundRequestModel : recordExists(userEmail, transactionId)
alt returns true
RefundRequestModel -->TransactionController : True
TransactionController -->Spring Dispatcher Serverlet: throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
else returns false
RefundRequestModel -->TransactionController: False
TransactionController ->RefundRequestModel : selectOne(userEmail, id)
RefundRequestModel --> TransactionController : TargetTransactoin (Transaction Object)
alt targetTransaction is not found 
TransactionController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
else targetTransaction is found
alt targetTransaction is of type refund 
TransactionController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
else transaction if not of type refund
TransactionController -> UserModel : insert(new RefundRequest(RefundRequest information)
UserModel-->TransactionController: 
TransactionController-->Spring Dispatcher Serverlet:
end
end 

end

title Recharge
actor user
boundary Spring Dispatcher Serverlet
control UserController
boundary TrasnactionModel
boundary UserModel
user ->Spring Dispatcher Serverlet : POST /user/recharge
Spring Dispatcher Serverlet ->UserController : rechargeWallet(Contex ctx, RechargeWalletBody body)
alt body.cardNumber is negative 
UserController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
else body.cardNumber is positive 
alt body.amount < 0


end 
end  

title pay using cash

actor user
boundary Spring Dispatcher Serverlet
control PaymentController
control ServiceController
control DiscountControlller
entity ProviderModel
entity DiscountModel
entity UsedDiscountModel
entity TransactionModel
participant CashOnDeliveryStrategy

participant handlerFactory

participant ErroneousHandler
participant handler

entity handlers

user->Spring Dispatcher Serverlet : POST /services/{serviceName}/providers/{providerName}/pay-cash
Spring Dispatcher Serverlet ->PaymentController : payCashOnDelivery(@RequestAttribute("context") Context ctx, @PathVariable("serviceName") String serviceName, @PathVariable("providerName") String providerName, @RequestBody PaymentBody body)

PaymentController ->ServiceController : getServiceProvider(serviceName, providerName)
ServiceController ->ServiceController : getService(serviceName)
ServiceController ->ProviderModel:selectOne(p -> p.serviceName.equals(serviceName) && p.name.equals(providerName))
ProviderModel -->ServiceController: Provider
alt provider = null
ServiceController -->PaymentController: throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Could not find a provider with such a name providing such a service")
PaymentController -->Spring Dispatcher Serverlet:
else provider != null
ServiceController -->PaymentController : provider
alt !provider.CashOnDelivery
PaymentController-->Spring Dispatcher Serverlet: throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "This provider does not provide cash on delivery")
PaymentController-->*CashOnDeliveryStrategy:<<create>>
end
PaymentController ->PaymentController : payToProvider(ctx.email, provider, body.handlerRequest, cashOnDeliveryStrategy)
PaymentController-->*handlerFactory:<<create>>
PaymentController ->handlerFactory: getHandler(provider.handlerName)
alt !handlers.containsKey(handlerName)
handlerFactory ->* ErroneousHandler:<<create>>
handlerFactory -->PaymentController : ErroneousHandler

end
handlerFactory -->handlers : get(handlerName);
handlers -->handlerFactory : handler
handlerFactory -->PaymentController : handler

end
PaymentController -> *handler: <<create>>
PaymentController -> handler: validateAndHandleRequest(request)
alt !requestContainsAllKeys(request)
handler ->*handlerResponse: <<create>>
handler -->PaymentController: handlerResponse
else requestContainsAllKeys(request)
handler->handler:handleRequestAndGetAmount(request)
alt !res.success
	handler -->PaymentController: handlerResponse
end 
	handler -->PaymentController: handlerResponse

alt !handlerRes.success
PaymentController -->Spring Dispatcher Serverlet:throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The form handler was not able to handle this request:\n" + handlerRes.errorMessage)
end
PaymentController ->DiscountControlller:getDiscountsForServiceForUser(email, provider.serviceName)
DiscountControlller ->DiscountModel: (d -> d.isActive && (d.type == DiscountType.OVERALL || (d.type == DiscountType.SPECIFIC && d.serviceName.equals(serviceName))))
DiscountControlller ->*Discounts: <<create>>
DiscountControlller ->DiscountControlller: getEffectiveDiscountsForUser(email, discounts)
DiscountControlller ->UsedDiscountModel: select(d -> d.email.equals(email))

UsedDiscountModel -->DiscountControlller : ArrayList<UsedDiscounts>
DiscountControlller -> Discounts: removeIf(d -> usedDiscountsIds.contains(d.id))
Discounts -->DiscountControlller : ArrayList<Discounts>user
DiscountControlller -->PaymentController: Discounts
PaymentController ->CashOnDeliveryStrategy : pay(amountToDeduct)
CashOnDeliveryStrategy -->PaymentController: 
PaymentController -> * transactionToInsert:<<create>>
PaymentController ->TransactionModel: insert(transactionToInsert)
TransactionModel -->PaymentController:
alt discount.type == DiscountType.OVERALL
PaymentController ->DiscountControlller : useDiscount(email, discount.id)
end
PaymentController -->Spring Dispatcher Serverlet:
end

title List Discounts
actor user
boundary Spring Dispatcher Serverlet
control DiscountController
entity discountModel
entity usedDiscountModel

user ->Spring Dispatcher Serverlet : GET /discounts
Spring Dispatcher Serverlet -> DiscountController : listDiscounts(@RequestAttribute("context") Context ctx, @RequestParam(required = false) String serviceName)

alt serviceName doesn't exist
DiscountController ->DiscountController : getEffectiveDiscountsForUser(ctx.email, discountModel.select(d -> d.isActive))
DiscountController ->usedDiscountModel : select(d -> d.email.equals(email))
usedDiscountModel -->DiscountController : ArrayList<UsedDiscount>
DiscountController -->Spring Dispatcher Serverlet : ArrayList<Discount>

else serviceName exists
DiscountController ->DiscountController : getDiscountsForServiceForUser(ctx.email, serviceName)
DiscountController ->discountModel : select(d -> d.isActive && (d.type == DiscountType.OVERALL || (d.type == DiscountType.SPECIFIC && d.serviceName.equals(serviceName))))
discountModel -->DiscountController : ArrayList<Discount>
DiscountController ->DiscountController : getEffectiveDiscountsForUser(email, discounts);
DiscountController ->usedDiscountModel : select(d -> d.email.equals(email))
usedDiscountModel -->DiscountController : ArrayList<UsedDiscount>
DiscountController -->Spring Dispatcher Serverlet : ArrayList<Discount>
end
title LogIn


actor user
boundary Spring Dispatcher Serverlet
control AuthController
entity UserModel
control Authenticator

user->Spring Dispatcher Serverlet:POST /login
Spring Dispatcher Serverlet ->AuthController : logIn(@RequestBody LogInBody body)
AuthController ->UserModel : selectOne(u -> u.email.equals(body.email) && u.password.equals(body.password))
UserModel -->AuthController : user

alt user != null
AuthController ->* Token:<<create>>user
Token -->AuthController:
AuthController -->Spring Dispatcher Serverlet : Token
end
AuthController -->Spring Dispatcher Serverlet:throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid email or password")
