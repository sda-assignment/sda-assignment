title Admin List Transactions
actor admin
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control AdminInterceptor
control AdminTransactionController
entity TransactionModel

admin ->Spring Dispatcher Serverlet : Get /admin/transactions
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
Spring Dispatcher Serverlet ->AdminInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AdminInterceptor -->Spring Dispatcher Serverlet : True
Spring Dispatcher Serverlet ->AdminTransactionController : listTransactions()
AdminTransactionController ->TransactionModel : select(t -> true)
TransactionModel -->AdminTransactionController : ArrayList<Transaction>
AdminTransactionController -->Spring Dispatcher Serverlet : ArrayList<Transaction>
else returns false
AdminInterceptor -->Spring Dispatcher Serverlet : throws ResponseStatusException
end
else returns false
AuthInterceptor -->Spring Dispatcher Serverlet : throws ResponseStatusException

end
==================================================
title SignUp

actor user
boundary Spring Dispatcher Serverlet
control AuthController
boundary "Model<User>" as UserModel

activate Spring Dispatcher Serverlet
user ->Spring Dispatcher Serverlet : POST /signup
Spring Dispatcher Serverlet ->AuthController : signUp(SignUpBody body)
activate AuthController
AuthController -> UserModel : recordExists(u -> u.email.equals(body.email))
activate UserModel
alt returns true
UserModel -->AuthController : True
AuthController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
Spring Dispatcher Serverlet --> user:400 Bad Request
else returns false
UserModel -->AuthController : False
AuthController ->UserModel : insert(new User(body.email, body.username, body.password, false, 0))
deactivate UserModel
deactivate AuthController

end
========================================
title Refund Request

actor user
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control TransactionController
entity "Model<RefundRequest>" as RefundRequestModel
entity "Model<Transaction>" as TransactionModel
entity UserModel
activate Spring Dispatcher Serverlet
activate AuthInterceptor
user ->Spring Dispatcher Serverlet : POST /transactions/{id}/refund
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
deactivate AuthInterceptor
Spring Dispatcher Serverlet ->TransactionController : requestRefund(Context ctx, int id)
activate TransactionController
TransactionController ->RefundRequestModel : recordExists(userEmail, transactionId)
activate RefundRequestModel
alt returns true
RefundRequestModel -->TransactionController : True
deactivate RefundRequestModel
TransactionController -->Spring Dispatcher Serverlet: throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
Spring Dispatcher Serverlet --> user:400 Bad Request
deactivate TransactionController
else returns false
activate TransactionController
activate RefundRequestModel
RefundRequestModel -->TransactionController: False
deactivate RefundRequestModel
TransactionController ->TransactionModel : selectOne(userEmail, id)
activate TransactionModel
TransactionModel --> TransactionController : TargetTransaction (Transaction Object)
deactivate TransactionModel
alt targetTransaction is not found
TransactionController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
Spring Dispatcher Serverlet --> user:400 Bad Request
deactivate TransactionController
else targetTransaction is found
activate TransactionController
alt targetTransaction is of type refund
TransactionController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
deactivate TransactionController
Spring Dispatcher Serverlet --> user:400 Bad Request
else transaction if not of type refund
activate TransactionController
TransactionController ->RefundRequestModel:refundRequestModel.selectMax(r -> r.id))
activate RefundRequestModel
RefundRequestModel-->TransactionController: RefundRequest object
deactivate RefundRequestModel
TransactionController -> UserModel : insert(new RefundRequest(Util.incrementOrIntialize(refundRequestModel.selectMax(r -> r.id)),id, RefundRequestStatus.PENDING, ctx.email))
Spring Dispatcher Serverlet --> user : 200 OK
activate UserModel
deactivate UserModel
deactivate TransactionController
end
end

end
else returns False
activate AuthInterceptor
AuthInterceptor -->Spring Dispatcher Serverlet : throws new ResponseStatusException (HttpStatus.UNAUTHORIZED)
Spring Dispatcher Serverlet --> user:401 UNAUTHROIZED
deactivate AuthInterceptor
end
=====================================
title Recharge
actor user
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control UserController
entity "Model<Transaction>" as TransactionModel
entity "Model<User>" as UserModel
activate Spring Dispatcher Serverlet
user ->Spring Dispatcher Serverlet : POST /user/recharge
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
activate AuthInterceptor
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
deactivate AuthInterceptor
Spring Dispatcher Serverlet ->UserController : rechargeWallet(Context ctx, RechargeWalletBody body)
activate UserController 
alt body.cardNumber is negative
UserController -->Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
deactivate UserController
Spring Dispatcher Serverlet --> user:400 Bad Request
else body.cardNumber is positive
activate UserController
alt body.amount < 0
UserController --> Spring Dispatcher Serverlet : throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
deactivate UserController
Spring Dispatcher Serverlet --> user:400 Bad Request
else body.amount >= 0
activate UserController
UserController ->UserModel : update(u -> new User(u.email, u.username, u.password, u.isAdmin, u.wallet + body.amount), u -> u.email.equals(ctx.email))
activate UserModel
deactivate UserModel
UserController ->TransactionModel : insert(new Transaction( Util.incrementOrIntialize (transactionModel.selectMax(t -> t.id)), ctx.email, LocalDateTime.now(), -body.amount, TransactionType.ADD_TO_WALLET, "None", "None"));
activate TransactionModel
deactivate TransactionModel
deactivate UserController
Spring Dispatcher Serverlet -->user: 200 OK
end
end
else returns False
activate AuthInterceptor
AuthInterceptor -->Spring Dispatcher Serverlet: throws new ResponseStatusException(HttpStatus.UNAUTHORIZED)
deactivate AuthInterceptor
Spring Dispatcher Serverlet --> user:401 UNAUTHORIZED
end
==============================================
title pay using cash

actor user
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control PaymentController
participant PayCashOnDeliveryStrategy
participant handlerFactory
participant concreteHandler
control ServiceController
entity ProviderModel
entity TransactionModel
control DiscountController
entity DiscountModel
entity UsedDiscountModel




user->Spring Dispatcher Serverlet : POST /services/{serviceName}/providers/{providerName}/pay-cash
activate Spring Dispatcher Serverlet
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
activate AuthInterceptor
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
deactivate AuthInterceptor
Spring Dispatcher Serverlet ->PaymentController : payCashOnDelivery(Context ctx, String serviceName, String providerName, PaymentBody body)
activate PaymentController

PaymentController ->ServiceController : getServiceProvider(String erviceName, String providerName)
activate ServiceController
ServiceController ->ServiceController : getService(String serviceName)
ServiceController ->ProviderModel:selectOne(p -> p.serviceName.equals(serviceName) && p.name.equals(providerName))
activate ProviderModel
ProviderModel -->ServiceController: return Provider
deactivate ProviderModel
destroysilent ProviderModel
alt provider = null
ServiceController -->PaymentController: throw new ResponseStatusException(HttpStatus.NOT_FOUND)
deactivate ServiceController
PaymentController -->Spring Dispatcher Serverlet: return throw new ResponseStatusException(HttpStatus.NOT_FOUND)
deactivate PaymentController
Spring Dispatcher Serverlet -->user: 404 NOT_FOUND
else provider != null
activate ServiceController 
activate PaymentController
ServiceController -->PaymentController : return Provider
deactivate ServiceController
destroysilent ServiceController
alt !provider.CashOnDelivery
PaymentController-->Spring Dispatcher Serverlet: throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
deactivate PaymentController
Spring Dispatcher Serverlet -->user:400 BAD_REQUEST
end
activate PaymentController
PaymentController-->*PayCashOnDeliveryStrategy:<<create>>
PaymentController ->PaymentController : payToProvider(ctx.email, provider, body.handlerRequest, cashOnDeliveryStrategy)
PaymentController-->*handlerFactory:<<create>>
PaymentController ->handlerFactory:getHandler(provider.handlerName)
activate handlerFactory
handlerFactory ->* concreteHandler:<<create>>
handlerFactory -->PaymentController : return concreteHandler object
deactivate handlerFactory
destroysilent handlerFactory
end
PaymentController -> concreteHandler : validateAndHandleRequest(HashMap<String, String> request)
activate concreteHandler
alt !requestContainsAllKeys(request) : Failure
concreteHandler -->PaymentController: return handlerResponse
PaymentController -->Spring Dispatcher Serverlet:throw new ResponseStatusException (HttpStatus.BAD_REQUEST)
deactivate PaymentController
Spring Dispatcher Serverlet -->user: 400 BAD_REQUEST
deactivate concreteHandler
else requestContainsAllKeys(request) : Success
activate concreteHandler
activate PaymentController
concreteHandler->concreteHandler:handleRequestAndGetAmount(HashMap <String, String> request)
alt !res.success (failure)
	concreteHandler -->PaymentController: return handlerResponse object
    deactivate concreteHandler
    PaymentController -->Spring Dispatcher Serverlet: :throw new ResponseStatusException(HttpStatus.BAD_REQUEST)
    deactivate PaymentController
    Spring Dispatcher Serverlet-->user:400 BAD_REQUEST
end
activate PaymentController
activate concreteHandler
	concreteHandler -->PaymentController: return new HandlerResponse(res.amount)
deactivate concreteHandler
destroysilent concreteHandler
PaymentController ->DiscountController:getDiscountsForServiceForUser(email, provider.serviceName)
activate DiscountController
DiscountController ->DiscountModel: select(d -> d.isActive && (d.type == DiscountType.OVERALL || (d.type == DiscountType.SPECIFIC && d.serviceName.equals(serviceName))))
activate DiscountModel
DiscountModel -->DiscountController: return Arraylisy<Discount>
destroysilent DiscountModel
deactivate DiscountModel
DiscountController ->DiscountController: getEffectiveDiscountsForUser(String email, ArrayList <Discount> discounts)
DiscountController ->UsedDiscountModel: select(d -> d.email.equals(email))
activate UsedDiscountModel
UsedDiscountModel -->DiscountController : ArrayList<UsedDiscount>
deactivate UsedDiscountModel
DiscountController -->PaymentController: ArrayList<Discount> discounts
deactivate DiscountController
PaymentController ->PayCashOnDeliveryStrategy : pay(amountToDeduct)
activate PayCashOnDeliveryStrategy
deactivate PayCashOnDeliveryStrategy
destroysilent PayCashOnDeliveryStrategy
PaymentController ->TransactionModel:selectMax(t-> t.id)
activate TransactionModel
TransactionModel -->PaymentController: Integer ID

PaymentController ->TransactionModel: insert(new transaction(ID,email, LocalDateTime.now(), amountToDeduct, TransactionType.PAYMENT, provider.serviceName, provider.name)))
deactivate TransactionModel
destroysilent TransactionModel
loop i from 0 to ArrayList<Discounts> discounts size
alt discount.type == DiscountType.OVERALL
PaymentController ->DiscountController : useDiscount(email, discount.id)
activate DiscountController
DiscountController ->UsedDiscountModel:insert(new UsedDiscount(email, discountId))
activate UsedDiscountModel
UsedDiscountModel-->DiscountController: return true
destroysilent DiscountController
deactivate UsedDiscountModel
destroysilent UsedDiscountModel
deactivate DiscountController
deactivate PaymentController
destroysilent PaymentController
end
end
Spring Dispatcher Serverlet --> user:200 OK
end
else returns False
activate AuthInterceptor
AuthInterceptor -->Spring Dispatcher Serverlet: throws new  ResponseStatusException(HttpStatus.UNAUTHORIZED)
deactivate AuthInterceptor
destroysilent AuthInterceptor
Spring Dispatcher Serverlet -->user: 401 UNAUTHORIZED

end
===========================================================================
title List Discounts
actor user
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control DiscountController
entity discountModel
entity usedDiscountModel

user ->Spring Dispatcher Serverlet : GET /discounts
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
Spring Dispatcher Serverlet -> DiscountController : listDiscounts(@RequestAttribute("context") Context ctx, @RequestParam(required = false) String serviceName)

alt serviceName doesn't exist
DiscountController ->DiscountController : getEffectiveDiscountsForUser(ctx.email, discountModel.select(d -> d.isActive))
DiscountController ->usedDiscountModel : select(d -> d.email.equals(email))
usedDiscountModel -->DiscountController : ArrayList<UsedDiscount>
DiscountController -->Spring Dispatcher Serverlet : ArrayList<Discount>

else serviceName exists
DiscountController ->DiscountController : getDiscountsForServiceForUser(ctx.email, serviceName)
DiscountController ->discountModel : select(d -> d.isActive && (d.type == DiscountType.OVERALL || (d.type == DiscountType.SPECIFIC && d.serviceName.equals(serviceName))))
discountModel -->DiscountController : ArrayList<Discount>
DiscountController ->DiscountController : getEffectiveDiscountsForUser(email, discounts);
DiscountController ->usedDiscountModel : select(d -> d.email.equals(email))
usedDiscountModel -->DiscountController : ArrayList<UsedDiscount>
DiscountController -->Spring Dispatcher Serverlet : ArrayList<Discount>
end
else returns False
AuthInterceptor -->Spring Dispatcher Serverlet: throws ResponseStatusException
end
=======================================================
title LogIn

actor user
boundary Spring Dispatcher Serverlet
control AuthController
entity "Model<User>" as UserModel

participant Token

activate Spring Dispatcher Serverlet

user->Spring Dispatcher Serverlet:POST /login
Spring Dispatcher Serverlet ->AuthController : logIn(@RequestBody LogInBody body)
activate AuthController
activate UserModel
AuthController ->UserModel : selectOne(u -> u.email.equals(body.email) && u.password.equals(body.password))
UserModel -->AuthController : user

alt user != null
AuthController ->* Token:<<create>>user
Token -->AuthController:
deactivate UserModel
AuthController -->Spring Dispatcher Serverlet : Token
deactivate AuthController
end
activate AuthController
AuthController -->Spring Dispatcher Serverlet:throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid email or password")
deactivate AuthController
======================================================================
title Admin List Refunds
actor admin
boundary Spring Dispatcher Serverlet
control AuthInterceptor
control AdminInterceptor
control AdminRefundController
entity refundModel
participant rrTransactions


admin -> Spring Dispatcher Serverlet : GET /admin/refunds
Spring Dispatcher Serverlet ->AuthInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AuthInterceptor -->Spring Dispatcher Serverlet: True
Spring Dispatcher Serverlet ->AdminInterceptor : preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
alt returns True
AdminInterceptor -->Spring Dispatcher Serverlet : True
Spring Dispatcher Serverlet ->AdminRefundController : listRefundRequests()
AdminRefundController ->refundModel : select(r -> true)
refundModel -->AdminRefundController : Model<RefundRequest>
AdminRefundController ->rrTransactions : add(new RefundRequestResponse(rr, transactionModel.selectOne(t -> t.id == rr.transactionId)))
rrTransactions -->AdminRefundController : ArrayList<RefundRequestResponse>
AdminRefundController -->Spring Dispatcher Serverlet : ArrayList<RefundRequestResponse>
else returns false
AdminInterceptor -->Spring Dispatcher Serverlet : throws ResponseStatusException
end
else returns false
AuthInterceptor -->Spring Dispatcher Serverlet : throws ResponseStatusException

end
